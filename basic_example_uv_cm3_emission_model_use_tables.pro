;+
; AUTHOR: Edward G. Nerney
; UV EMISSION MODEL FOR IO PLASMA TORUS - TABLE-BASED VERSION
; ============================================================
; This code simulates UV emission spectra from the Io Plasma Torus (IPT) in
; Jupiter's magnetosphere using pre-calculated CHIANTI emission tables.
;
; ADVANTAGES OVER DIRECT CHIANTI CALLS:
; - Much faster execution (interpolation vs full atomic calculations)
; - No CHIANTI installation required for users
; - Portable - only needs the .sav files with emission tables
; - Reproducible results across different systems
;
; PHYSICAL MODEL:
; - Uses pre-calculated emissivities from CHIANTI 11.0.2
; - Supports both single and double Maxwellian electron distributions
; - Double Maxwellian uses proper 4D interpolation (not linear superposition)
; - Converts atomic emissivities to observable Rayleigh intensities
; - Applies realistic instrument response function
;
; REQUIRED FILES:
; - Single Maxwellian: CHIANTI_11.0.2_emiss_arrays_all_species_all_wavelengths_50x50_logspaced.sav
; - Double Maxwellian: CHIANTI_11.0.2_emiss_arrays_all_species_all_wavelengths_15x10x20x10_hote_logspaced.sav
;   (Generated by make_emission_tables_chianti11.pro)
;
; REFERENCES:
; - Nerney et al. 2017, 2020, 2022, & 2025
; - Steffl et al. 2004b
; - CHIANTI atomic database (Dere et al. 1997, Del Zanna et al. 2020, & Dufresne et al. 2024)
;-

;==============================================================================
function interpolate_emissivity_2D, temp_eV, dens_cm3, temp_arr, dens_arr, emiss_table
  ;+
  ; NAME:
  ;   interpolate_emissivity_2D
  ;
  ; PURPOSE:
  ;   Use IDL's GRIDDATA function to interpolate 2D emissivities for single
  ;   Maxwellian case at specific temperature and density.
  ;
  ; INPUTS:
  ;   temp_eV    - Electron temperature [eV] to interpolate at
  ;   dens_cm3   - Electron density [cm^-3] to interpolate at
  ;   temp_arr   - Temperature grid from tables [eV]
  ;   dens_arr   - Density grid from tables [cm^-3]
  ;   emiss_table - 3D emissivity table [n_temp, n_dens, n_lines]
  ;
  ; OUTPUTS:
  ;   Returns 1D array of interpolated emissivities for all wavelengths
  ;
  ; METHOD:
  ;   Uses IDL's GRIDDATA function with linear interpolation in log10(T) - log10(n)
  ;   space for smooth interpolation of emissivities which vary as power laws.
  ;-

  ; Get dimensions
  n_temp = n_elements(temp_arr)
  n_dens = n_elements(dens_arr)
  n_lines = (size(emiss_table))[3]

  ; Convert to log10 space for interpolation
  log10_temp = alog10(temp_eV)
  log10_dens = alog10(dens_cm3)
  log10_temp_arr = alog10(temp_arr)
  log10_dens_arr = alog10(dens_arr)

  ; Create 2D grid of input points for GRIDDATA
  ; Need to flatten the grid into lists of X,Y coordinates
  temp_grid = rebin(log10_temp_arr, n_temp, n_dens)
  dens_grid = rebin(reform(log10_dens_arr, 1, n_dens), n_temp, n_dens)

  ; Flatten the coordinate grids
  x_points = reform(temp_grid, n_temp * n_dens)
  y_points = reform(dens_grid, n_temp * n_dens)

  ; Compute Delaunay triangulation once (required for LINEAR method)
  TRIANGULATE, x_points, y_points, triangles

  ; Initialize output array
  emiss_interp = dblarr(n_lines)

  ; Interpolate each wavelength separately
  for i = 0, n_lines - 1 do begin
    ; Extract and flatten the emissivity values for this wavelength
    f_values = reform(emiss_table[*, *, i], n_temp * n_dens)

    ; Use GRIDDATA to interpolate at the desired point
    ; Using LINEAR method for smooth interpolation
    interp_value = GRIDDATA(x_points, y_points, f_values, $
      /LINEAR, TRIANGLES=triangles, /GRID, $
      XOUT=[log10_temp], YOUT=[log10_dens], $
      MISSING=0d)

    emiss_interp[i] = interp_value
  endfor

  ; Handle any negative values from interpolation (set to zero)
  neg_idx = where(emiss_interp lt 0, n_neg)
  if n_neg gt 0 then emiss_interp[neg_idx] = 0d

  return, emiss_interp
end

;==============================================================================
function interpolate_emissivity_4D, Tec_eV, Teh_eV, ne_cm3, feh, $
  tec_arr, teh_arr, ne_arr, feh_arr, emiss_table
  ;+
  ; NAME:
  ;   interpolate_emissivity_4D
  ;
  ; PURPOSE:
  ;   Interpolate 4D emissivity tables for double Maxwellian case.
  ;   Uses proper 4D interpolation since emission is nonlinear in the parameters.
  ;
  ; INPUTS:
  ;   Tec_eV      - Core electron temperature [eV]
  ;   Teh_eV      - Hot electron temperature [eV]
  ;   ne_cm3      - Total electron density [cm^-3]
  ;   feh         - Hot electron fraction
  ;   tec_arr     - Core temperature grid [eV]
  ;   teh_arr     - Hot temperature grid [eV]
  ;   ne_arr      - Density grid [cm^-3]
  ;   feh_arr     - Hot fraction grid
  ;   emiss_table - 5D table [n_tec, n_teh, n_ne, n_feh, n_lines]
  ;
  ; OUTPUTS:
  ;   Returns 1D array of interpolated emissivities
  ;
  ; METHOD:
  ;   Uses 4D linear interpolation in log space for temperatures and densities.
  ;   Linear interpolation in normal space for fraction.
  ;-

  ; Get dimensions
  n_tec = n_elements(tec_arr)
  n_teh = n_elements(teh_arr)
  n_ne = n_elements(ne_arr)
  n_feh = n_elements(feh_arr)
  n_lines = (size(emiss_table))[5]

  ; Convert to appropriate interpolation spaces
  log10_tec = alog10(Tec_eV)
  log10_teh = alog10(Teh_eV)
  log10_ne = alog10(ne_cm3)

  log10_tec_arr = alog10(tec_arr)
  log10_teh_arr = alog10(teh_arr)
  log10_ne_arr = alog10(ne_arr)

  ; Find indices for interpolation using VALUE_LOCATE
  itec = value_locate(log10_tec_arr, log10_tec)
  iteh = value_locate(log10_teh_arr, log10_teh)
  ine = value_locate(log10_ne_arr, log10_ne)
  ifeh = value_locate(feh_arr, feh)

  ; Handle edge cases
  if itec lt 0 then itec = 0
  if itec ge n_tec-1 then itec = n_tec-2
  if iteh lt 0 then iteh = 0
  if iteh ge n_teh-1 then iteh = n_teh-2
  if ine lt 0 then ine = 0
  if ine ge n_ne-1 then ine = n_ne-2
  if ifeh lt 0 then ifeh = 0
  if ifeh ge n_feh-1 then ifeh = n_feh-2

  ; Calculate interpolation weights
  wtec = (log10_tec - log10_tec_arr[itec]) / (log10_tec_arr[itec+1] - log10_tec_arr[itec])
  wteh = (log10_teh - log10_teh_arr[iteh]) / (log10_teh_arr[iteh+1] - log10_teh_arr[iteh])
  wne = (log10_ne - log10_ne_arr[ine]) / (log10_ne_arr[ine+1] - log10_ne_arr[ine])
  wfeh = (feh - feh_arr[ifeh]) / (feh_arr[ifeh+1] - feh_arr[ifeh])

  ; Initialize output
  emiss_interp = dblarr(n_lines)

  ; Perform 4D linear interpolation for each wavelength
  for iline = 0, n_lines - 1 do begin
    ; Extract the 16 corner points of the 4D hypercube
    v0000 = emiss_table[itec,   iteh,   ine,   ifeh,   iline]
    v0001 = emiss_table[itec,   iteh,   ine,   ifeh+1, iline]
    v0010 = emiss_table[itec,   iteh,   ine+1, ifeh,   iline]
    v0011 = emiss_table[itec,   iteh,   ine+1, ifeh+1, iline]
    v0100 = emiss_table[itec,   iteh+1, ine,   ifeh,   iline]
    v0101 = emiss_table[itec,   iteh+1, ine,   ifeh+1, iline]
    v0110 = emiss_table[itec,   iteh+1, ine+1, ifeh,   iline]
    v0111 = emiss_table[itec,   iteh+1, ine+1, ifeh+1, iline]
    v1000 = emiss_table[itec+1, iteh,   ine,   ifeh,   iline]
    v1001 = emiss_table[itec+1, iteh,   ine,   ifeh+1, iline]
    v1010 = emiss_table[itec+1, iteh,   ine+1, ifeh,   iline]
    v1011 = emiss_table[itec+1, iteh,   ine+1, ifeh+1, iline]
    v1100 = emiss_table[itec+1, iteh+1, ine,   ifeh,   iline]
    v1101 = emiss_table[itec+1, iteh+1, ine,   ifeh+1, iline]
    v1110 = emiss_table[itec+1, iteh+1, ine+1, ifeh,   iline]
    v1111 = emiss_table[itec+1, iteh+1, ine+1, ifeh+1, iline]

    ; 4D linear interpolation
    emiss_interp[iline] = $
      v0000 * (1-wtec) * (1-wteh) * (1-wne) * (1-wfeh) + $
      v0001 * (1-wtec) * (1-wteh) * (1-wne) * wfeh + $
      v0010 * (1-wtec) * (1-wteh) * wne * (1-wfeh) + $
      v0011 * (1-wtec) * (1-wteh) * wne * wfeh + $
      v0100 * (1-wtec) * wteh * (1-wne) * (1-wfeh) + $
      v0101 * (1-wtec) * wteh * (1-wne) * wfeh + $
      v0110 * (1-wtec) * wteh * wne * (1-wfeh) + $
      v0111 * (1-wtec) * wteh * wne * wfeh + $
      v1000 * wtec * (1-wteh) * (1-wne) * (1-wfeh) + $
      v1001 * wtec * (1-wteh) * (1-wne) * wfeh + $
      v1010 * wtec * (1-wteh) * wne * (1-wfeh) + $
      v1011 * wtec * (1-wteh) * wne * wfeh + $
      v1100 * wtec * wteh * (1-wne) * (1-wfeh) + $
      v1101 * wtec * wteh * (1-wne) * wfeh + $
      v1110 * wtec * wteh * wne * (1-wfeh) + $
      v1111 * wtec * wteh * wne * wfeh
  endfor

  ; Handle any negative values
  neg_idx = where(emiss_interp lt 0, n_neg)
  if n_neg gt 0 then emiss_interp[neg_idx] = 0d

  return, emiss_interp
end

;==============================================================================
function calculate_IPT_emiss_tables_single, Tel, nel, Nsp, Ns2p, Ns3p, Ns4p, Nop, No2p, $
  temp_arr, dens_arr, xwavi_struct, yptsi_struct, $
  min = min, max = max, xwavi=xwavi
  ;+
  ; NAME:
  ;   calculate_IPT_emiss_tables_single
  ;
  ; PURPOSE:
  ;   Calculate UV emission line intensities for a SINGLE Maxwellian electron
  ;   distribution using pre-calculated emission tables.
  ;
  ; INPUTS:
  ;   Tel          - Electron temperature [eV]
  ;   nel          - Electron number density [#/cm^3]
  ;   Nsp          - S+ (S II) column density [#/cm^2]
  ;   Ns2p         - S++ (S III) column density [#/cm^2]
  ;   Ns3p         - S+++ (S IV) column density [#/cm^2]
  ;   Ns4p         - S++++ (S V) column density [#/cm^2]
  ;   Nop          - O+ (O II) column density [#/cm^2]
  ;   No2p         - O++ (O III) column density [#/cm^2]
  ;   temp_arr     - Temperature grid from tables [eV]
  ;   dens_arr     - Density grid from tables [cm^-3]
  ;   xwavi_struct - Structure containing wavelength arrays for each ion
  ;   yptsi_struct - Structure containing emissivity tables for each ion
  ;
  ; KEYWORDS:
  ;   min    - Minimum wavelength [Angstroms], default=550
  ;   max    - Maximum wavelength [Angstroms], default=1800
  ;   xwavi  - OUTPUT: Array of emission line wavelengths [Angstroms]
  ;
  ; OUTPUTS:
  ;   Returns 1D array of line intensities in Rayleighs
  ;-

  ; Set wavelength range
  if keyword_set(max) then maxwav = max else maxwav = 1800d
  if keyword_set(min) then minwav = min else minwav = 550d

  ; ============================================================================
  ; INTERPOLATE EMISSIVITIES FOR EACH ION
  ; ============================================================================

  ; S+ (note: 's' field contains neutral S which we skip for IPT)
  emiss_sp = interpolate_emissivity_2D(Tel, nel, temp_arr, dens_arr, yptsi_struct.sp)

  ; S++
  emiss_s2p = interpolate_emissivity_2D(Tel, nel, temp_arr, dens_arr, yptsi_struct.s2p)

  ; S+++
  emiss_s3p = interpolate_emissivity_2D(Tel, nel, temp_arr, dens_arr, yptsi_struct.s3p)

  ; S++++
  emiss_s4p = interpolate_emissivity_2D(Tel, nel, temp_arr, dens_arr, yptsi_struct.s4p)

  ; O+
  emiss_op = interpolate_emissivity_2D(Tel, nel, temp_arr, dens_arr, yptsi_struct.op)

  ; O++
  emiss_o2p = interpolate_emissivity_2D(Tel, nel, temp_arr, dens_arr, yptsi_struct.o2p)

  ; ============================================================================
  ; CONVERT TO OBSERVABLE INTENSITIES
  ; ============================================================================
  ; Multiply volume emissivity by column density and convert to Rayleighs
  ; Emissivities from CHIANTI are in photons/s
  ; 1 Rayleigh = 10^6 photons/s/cm^2/4π sr (hence the 1d-6 factor)

  sp_intensity = (1d-6) * emiss_sp * Nsp    ; S II lines
  s2p_intensity = (1d-6) * emiss_s2p * Ns2p ; S III lines
  s3p_intensity = (1d-6) * emiss_s3p * Ns3p ; S IV lines
  s4p_intensity = (1d-6) * emiss_s4p * Ns4p ; S V lines
  op_intensity = (1d-6) * emiss_op * Nop    ; O II lines
  o2p_intensity = (1d-6) * emiss_o2p * No2p ; O III lines

  ; ============================================================================
  ; COMBINE WAVELENGTHS AND INTENSITIES
  ; ============================================================================

  xwavi_all = [xwavi_struct.sp, xwavi_struct.s2p, xwavi_struct.s3p, $
    xwavi_struct.s4p, xwavi_struct.op, xwavi_struct.o2p]

  yptsi_all = [sp_intensity, s2p_intensity, s3p_intensity, $
    s4p_intensity, op_intensity, o2p_intensity]

  ; Sort by wavelength
  wsort = sort(xwavi_all)
  xwavi_all = xwavi_all[wsort]
  yptsi_all = yptsi_all[wsort]

  ; ============================================================================
  ; FILTER TO REQUESTED WAVELENGTH RANGE
  ; ============================================================================
  avgwav = (minwav + maxwav)/2.d
  wrange = where(abs(xwavi_all - avgwav) le avgwav - minwav, nlines)

  if nlines gt 0 then begin
    xwavi = xwavi_all[wrange]
    yptsi = yptsi_all[wrange]
  endif else begin
    ; Return empty arrays if no lines in range
    xwavi = [0d]
    yptsi = [0d]
  endelse

  return, yptsi
end

;==============================================================================
function calculate_IPT_emiss_tables_double, Tec, Teh, ne_total, feh, $
  Nsp, Ns2p, Ns3p, Ns4p, Nop, No2p, $
  tec_arr, teh_arr, ne_arr, feh_arr, xwavi_struct, yptsi_struct, $
  min = min, max = max, xwavi=xwavi
  ;+
  ; NAME:
  ;   calculate_IPT_emiss_tables_double
  ;
  ; PURPOSE:
  ;   Calculate UV emission for a DOUBLE Maxwellian electron distribution
  ;   using pre-calculated 4D emission tables. This properly accounts for
  ;   the nonlinear nature of emission vs electron distribution parameters.
  ;
  ; INPUTS:
  ;   Tec          - Core (cold) electron temperature [eV]
  ;   Teh          - Hot electron temperature [eV]
  ;   ne_total     - Total electron density [#/cm^3]
  ;   feh          - Fraction of hot electrons (0 to 1)
  ;   Nsp          - S+ column density [#/cm^2]
  ;   Ns2p         - S++ column density [#/cm^2]
  ;   Ns3p         - S+++ column density [#/cm^2]
  ;   Ns4p         - S++++ column density [#/cm^2]
  ;   Nop          - O+ column density [#/cm^2]
  ;   No2p         - O++ column density [#/cm^2]
  ;   tec_arr      - Core temperature grid from tables [eV]
  ;   teh_arr      - Hot temperature grid from tables [eV]
  ;   ne_arr       - Density grid from tables [cm^-3]
  ;   feh_arr      - Hot fraction grid from tables
  ;   xwavi_struct - Structure containing wavelength arrays
  ;   yptsi_struct - Structure containing 4D emissivity tables
  ;
  ; KEYWORDS:
  ;   min      - Minimum wavelength [Angstroms]
  ;   max      - Maximum wavelength [Angstroms]
  ;   xwavi    - OUTPUT: Emission line wavelengths
  ;
  ; PHYSICS:
  ;   Uses proper 4D interpolation of pre-calculated tables that account
  ;   for the nonlinear relationship between emission and the double
  ;   Maxwellian parameters.
  ;-

  ; Set wavelength range
  if keyword_set(max) then maxwav = max else maxwav = 1800d
  if keyword_set(min) then minwav = min else minwav = 550d

  ; ============================================================================
  ; INTERPOLATE 4D EMISSIVITIES FOR EACH ION
  ; ============================================================================

  ; S+
  emiss_sp = interpolate_emissivity_4D(Tec, Teh, ne_total, feh, $
    tec_arr, teh_arr, ne_arr, feh_arr, yptsi_struct.sp)

  ; S++
  emiss_s2p = interpolate_emissivity_4D(Tec, Teh, ne_total, feh, $
    tec_arr, teh_arr, ne_arr, feh_arr, yptsi_struct.s2p)

  ; S+++
  emiss_s3p = interpolate_emissivity_4D(Tec, Teh, ne_total, feh, $
    tec_arr, teh_arr, ne_arr, feh_arr, yptsi_struct.s3p)

  ; S++++
  emiss_s4p = interpolate_emissivity_4D(Tec, Teh, ne_total, feh, $
    tec_arr, teh_arr, ne_arr, feh_arr, yptsi_struct.s4p)

  ; O+
  emiss_op = interpolate_emissivity_4D(Tec, Teh, ne_total, feh, $
    tec_arr, teh_arr, ne_arr, feh_arr, yptsi_struct.op)

  ; O++
  emiss_o2p = interpolate_emissivity_4D(Tec, Teh, ne_total, feh, $
    tec_arr, teh_arr, ne_arr, feh_arr, yptsi_struct.o2p)

  ; ============================================================================
  ; CONVERT TO OBSERVABLE INTENSITIES
  ; ============================================================================

  sp_intensity = (1d-6) * emiss_sp * Nsp
  s2p_intensity = (1d-6) * emiss_s2p * Ns2p
  s3p_intensity = (1d-6) * emiss_s3p * Ns3p
  s4p_intensity = (1d-6) * emiss_s4p * Ns4p
  op_intensity = (1d-6) * emiss_op * Nop
  o2p_intensity = (1d-6) * emiss_o2p * No2p

  ; ============================================================================
  ; COMBINE AND SORT
  ; ============================================================================

  xwavi_all = [xwavi_struct.sp, xwavi_struct.s2p, xwavi_struct.s3p, $
    xwavi_struct.s4p, xwavi_struct.op, xwavi_struct.o2p]

  yptsi_all = [sp_intensity, s2p_intensity, s3p_intensity, $
    s4p_intensity, op_intensity, o2p_intensity]

  ; Sort by wavelength
  wsort = sort(xwavi_all)
  xwavi_all = xwavi_all[wsort]
  yptsi_all = yptsi_all[wsort]

  ; Filter to wavelength range
  avgwav = (minwav + maxwav)/2.d
  wrange = where(abs(xwavi_all - avgwav) le avgwav - minwav, nlines)

  if nlines gt 0 then begin
    xwavi = xwavi_all[wrange]
    yptsi = yptsi_all[wrange]
  endif else begin
    xwavi = [0d]
    yptsi = [0d]
  endelse

  return, yptsi
end

;==============================================================================
function simulate_IPT_spectrum_Rayleighs_ERF_form, x, spec_binsize, xwavi, yptsi, $
  fwhm = fwhm
  ;+
  ; NAME:
  ;   simulate_IPT_spectrum_Rayleighs_ERF_form
  ;
  ; PURPOSE:
  ;   Convolve discrete emission lines with instrument response function to
  ;   create a realistic spectrum as would be observed by a spectrograph.
  ;
  ; INPUTS:
  ;   x            - Wavelength grid for output spectrum [Angstroms]
  ;   spec_binsize - Width of wavelength bins [Angstroms]
  ;   xwavi        - Wavelengths of emission lines [Angstroms]
  ;   yptsi        - Intensities of emission lines [Rayleighs]
  ;
  ; KEYWORDS:
  ;   fwhm         - Full Width Half Maximum of Gaussian instrument response [Angstroms]
  ;
  ; METHOD:
  ;   Uses Error Function (ERF) formulation for exact integration of Gaussian
  ;   line profile over finite wavelength bins.
  ;-

  ; Gaussian profile parameters
  rootc = 2d*sqrt(alog(2d))/fwhm  ; This is 1/(σ√2)

  ; Get dimensions
  nj = n_elements(x)     ; Number of wavelength bins
  ni = n_elements(yptsi) ; Number of emission lines

  ; Initialize output spectrum
  ypts = dblarr(nj)

  ; Convolve each line with instrument response
  for i=0, ni-1 do begin
    ; Skip lines with zero or negative intensity
    if yptsi[i] le 0 then continue

    ; Calculate contribution to each wavelength bin
    ypts += yptsi(i) * 0.5d * $
      (Erf((x - xwavi(i) + spec_binsize/2d)*rootc) - $
      Erf((x - xwavi(i) - spec_binsize/2d)*rootc))
  endfor

  ; Convert from integrated intensity to intensity per unit wavelength
  ypts /= spec_binsize

  return, ypts
end

;==============================================================================
pro basic_example_uv_cm3_emission_model_use_tables
  ;+
  ; NAME:
  ;   basic_example_uv_cm3_emission_model_use_tables
  ;
  ; PURPOSE:
  ;   Main procedure demonstrating UV emission calculations for the Io Plasma
  ;   Torus using pre-calculated CHIANTI emission tables. This version does not
  ;   require CHIANTI to be installed - only needs the .sav files with tables.
  ;
  ; DESCRIPTION:
  ;   This procedure:
  ;   1. Loads pre-calculated emission tables from .sav files
  ;   2. Sets up typical IPT plasma parameters
  ;   3. Calculates UV emission spectra using table interpolation
  ;   4. Demonstrates both single and double Maxwellian cases
  ;   5. Plots the resulting spectra
  ;
  ; OUTPUTS:
  ;   Creates plots showing simulated UV spectra in Rayleighs/Angstrom
  ;
  ; REQUIRED FILES:
  ;   For single Maxwellian:
  ;     CHIANTI_11.0.2_emiss_arrays_all_species_all_wavelengths_50x50_logspaced.sav
  ;   For double Maxwellian:
  ;     CHIANTI_11.0.2_emiss_arrays_all_species_all_wavelengths_15x10x20x10_hote_logspaced.sav
  ;-

  ; ============================================================================
  ; WAVELENGTH GRID SETUP
  ; ============================================================================
  ; Define the wavelength range and resolution for the simulation

  min_xwav = 550d        ; Minimum wavelength [Angstroms]
  max_xwav = 1750d       ; Maximum wavelength [Angstroms]
  xwav_bin_width = 1d    ; Spectral bin width [Angstroms]

  ; Calculate number of wavelength bins
  num_xwav_points = floor((max_xwav - min_xwav)/xwav_bin_width) + 1

  ; Create wavelength grid (bin centers)
  xwav = xwav_bin_width*dindgen(num_xwav_points) + min_xwav

  ; ============================================================================
  ; INSTRUMENT PARAMETERS
  ; ============================================================================
  ; Full Width Half Maximum of instrument response function
  fwhm = 4d  ; [Angstroms] - typical for space-based UV spectrographs

  ; ============================================================================
  ; PLASMA PARAMETERS
  ; ============================================================================
  ; Core/cold electron population parameters
  Tec = 5d        ; Core electron temperature [eV]
  nec = 2200d     ; Core electron density [#/cm^3]

  ; Hot electron component (suprathermal population)
  Teh = 270d      ; Hot electron temperature [eV]
  feh = 0.0025d   ; Fraction of hot electrons (0.25% typical)
  fec = 1d - feh  ; Fraction of cold electrons

  ; Calculate densities for double Maxwellian
  neh = nec*(1d/fec - 1d)  ; Hot electron density
  ne_total = nec + neh     ; Total electron density

  ; ============================================================================
  ; COLUMN DENSITIES AND ION COMPOSITION
  ; ============================================================================
  ; Total electron column density for line-of-sight through torus
  Ne_column = 2d14  ; [cm^-2] - integrated electron density along LOS

  ; Ion mixing ratios at 6 R_J (from observations)
  ; Based on Nerney et al. 2017 and Steffl et al. 2004b

  ; Sulfur ion mixing ratios
  Nsp_mixr = 0.06d     ; S+ (S II)
  Ns2p_mixr = 0.21d    ; S++ (S III) - dominant S ion
  Ns3p_mixr = 0.0296d  ; S+++ (S IV)
  Ns4p_mixr = 0.003d   ; S++++ (S V)

  ; Oxygen ion mixing ratios
  Nop_mixr = 0.26d     ; O+ (O II) - dominant ion overall
  No2p_mixr = 0.0296d  ; O++ (O III)

  ; Calculate ion column densities from mixing ratios
  Nsp = Ne_column*Nsp_mixr    ; S+ column density [cm^-2]
  Ns2p = Ne_column*Ns2p_mixr  ; S++ column density [cm^-2]
  Ns3p = Ne_column*Ns3p_mixr  ; S+++ column density [cm^-2]
  Ns4p = Ne_column*Ns4p_mixr  ; S++++ column density [cm^-2]
  Nop = Ne_column*Nop_mixr    ; O+ column density [cm^-2]
  No2p = Ne_column*No2p_mixr  ; O++ column density [cm^-2]

  ; ============================================================================
  ; LOAD AND CALCULATE SINGLE MAXWELLIAN EMISSION
  ; ============================================================================
  print, '================================================================'
  print, 'SINGLE MAXWELLIAN CALCULATION'
  print, '================================================================'
  print, 'Loading single Maxwellian emission tables...'

  ; Load the 2D emission tables for single Maxwellian
  restore, 'CHIANTI_11.0.2_emiss_arrays_all_species_all_wavelengths_50x50_logspaced.sav'
  ; Restored variables: DENS_ARR, TEMP_ARR, XWAVI, YPTSI

  print, 'Tables loaded successfully:'
  print, '  Temperature range: ', min(temp_arr), ' - ', max(temp_arr), ' eV'
  print, '  Density range: ', min(dens_arr), ' - ', max(dens_arr), ' cm^-3'
  print, '  Grid size: ', n_elements(temp_arr), ' x ', n_elements(dens_arr)

  print, 'Calculating single Maxwellian emission using tables...'
  yptsi_single_maxwellian = calculate_IPT_emiss_tables_single(Tec, nec, $
    Nsp, Ns2p, Ns3p, Ns4p, Nop, No2p, $
    temp_arr, dens_arr, xwavi, yptsi, $
    min = min_xwav, max = max_xwav, xwavi=xwavi_single)

  ; Convolve with instrument response
  ypts_single_maxwellian = simulate_IPT_spectrum_Rayleighs_ERF_form( $
    xwav, xwav_bin_width, xwavi_single, yptsi_single_maxwellian, fwhm = fwhm)

  ; ============================================================================
  ; LOAD AND CALCULATE DOUBLE MAXWELLIAN EMISSION
  ; ============================================================================
  print, ''
  print, '================================================================'
  print, 'DOUBLE MAXWELLIAN CALCULATION'
  print, '================================================================'
  print, 'Loading double Maxwellian emission tables...'

  ; Load the 4D emission tables for double Maxwellian
  restore, 'CHIANTI_11.0.2_emiss_arrays_all_species_all_wavelengths_15x10x20x10_hote_logspaced.sav'
  ; Restored variables: TEC_ARR, TEH_ARR, NE_ARR, FEH_ARR, XWAVI, YPTSI

  print, 'Tables loaded successfully:'
  print, '  Core temperature range: ', min(tec_arr), ' - ', max(tec_arr), ' eV'
  print, '  Hot temperature range: ', min(teh_arr), ' - ', max(teh_arr), ' eV'
  print, '  Density range: ', min(ne_arr), ' - ', max(ne_arr), ' cm^-3'
  print, '  Hot fraction range: ', min(feh_arr), ' - ', max(feh_arr)
  print, '  Grid size: ', n_elements(tec_arr), ' x ', n_elements(teh_arr), $
    ' x ', n_elements(ne_arr), ' x ', n_elements(feh_arr)

  print, 'Calculating double Maxwellian emission using 4D tables...'
  yptsi_double_maxwellian = calculate_IPT_emiss_tables_double( $
    Tec, Teh, ne_total, feh, $
    Nsp, Ns2p, Ns3p, Ns4p, Nop, No2p, $
    tec_arr, teh_arr, ne_arr, feh_arr, xwavi, yptsi, $
    min = min_xwav, max = max_xwav, xwavi=xwavi_double)

  ; Convolve with instrument response
  ypts_double_maxwellian = simulate_IPT_spectrum_Rayleighs_ERF_form( $
    xwav, xwav_bin_width, xwavi_double, yptsi_double_maxwellian, fwhm = fwhm)

  ; ============================================================================
  ; PLOT RESULTS
  ; ============================================================================
  ; Create plots showing the simulated spectra

  p1 = plot(xwav, ypts_single_maxwellian, $
    xtitle='Wavelength (Å)', $
    ytitle='Intensity (Rayleighs/Å)', $
    title='IPT UV Emission (Table-based): Single Maxwellian (T$_{e}$=' + $
    string(Tec,format='(F4.1)') + ' eV, n$_{e}$=' + $
    string(nec,format='(F6.1)') +' cm$^{-3}$)', $
    thick=2, color='black')

  p2 = plot(xwav, ypts_double_maxwellian, $
    xtitle='Wavelength (Å)', $
    ytitle='Intensity (Rayleighs/Å)', $
    title='IPT UV Emission (Table-based): Double Maxwellian (T$_{ec}$=' + $
    string(Tec,format='(F4.1)') + ' eV, T$_{eh}$=' + $
    string(Teh,format='(F5.1)') + ' eV, f$_{eh}$=' + $
    string(feh,format='(F6.4)') + ')', $
    thick=2, color='red')

  ; ============================================================================
  ; COMPARISON PLOT
  ; ============================================================================
  ; Plot both spectra on same axes for comparison

  p3 = plot(xwav, ypts_single_maxwellian, $
    xtitle='Wavelength (Å)', $
    ytitle='Intensity (Rayleighs/Å)', $
    title='IPT UV Emission Comparison (Table-based)', $
    thick=2, color='black', $
    name='Single Maxwellian')

  p3b = plot(xwav, ypts_double_maxwellian, $
    /overplot, $
    thick=2, color='red', $
    name='Double Maxwellian',transparency=50)

  ; Add legend
  leg = legend(target=[p3, p3b], $
    position=[0.7, 0.8], $
    /normal, $
    font_size=10)

  ; ============================================================================
  ; SUMMARY OUTPUT
  ; ============================================================================
  print, ''
  print, '================================================================'
  print, 'SIMULATION COMPLETE - TABLE-BASED VERSION'
  print, '================================================================'
  print, 'Plasma parameters used:'
  print, '  Single Maxwellian: Te =', Tec, ' eV, ne =', nec, ' cm^-3'
  print, '  Double Maxwellian: Tec =', Tec, ' eV, Teh =', Teh, ' eV'
  print, '                     feh =', feh, ', ne_total =', ne_total, ' cm^-3'
  print, ''
  print, 'Column densities [cm^-2]:'
  print, '  S+   :', Nsp
  print, '  S++  :', Ns2p
  print, '  S+++ :', Ns3p
  print, '  S++++:', Ns4p
  print, '  O+   :', Nop
  print, '  O++  :', No2p
  print, ''
  print, 'Number of emission lines in range:'
  print, '  Single Maxwellian:', n_elements(xwavi_single)
  print, '  Double Maxwellian:', n_elements(xwavi_double)
  print, ''
  print, 'Variables available for inspection:'
  print, '  xwav                    - wavelength grid'
  print, '  ypts_single_maxwellian  - single Maxwellian spectrum'
  print, '  ypts_double_maxwellian  - double Maxwellian spectrum'
  print, '  xwavi_single/double     - emission line wavelengths'
  print, '  yptsi_single/double     - emission line intensities'
  stop  ; Pause to allow examination of results

end